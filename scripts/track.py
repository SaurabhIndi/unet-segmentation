import os
import numpy as np
from PIL import Image
import glob
from collections import defaultdict
from scipy.optimize import linear_sum_assignment # For optimal matching

# --- Configuration ---
# Input directory for instance masks generated by predict.py
# IMPORTANT: Adjust this path to where your '01_RES_INST' folder is located
INSTANCE_MASKS_ROOT = 'C:/Users/saura/Downloads/unet-segmentation/data/raw/processed/predictions/DIC-C2DH-HeLa'
SEQUENCE_NAME = '01' # The specific sequence you are tracking (e.g., '01' or '02')
INSTANCE_MASKS_DIR = os.path.join(INSTANCE_MASKS_ROOT, f'{SEQUENCE_NAME}_RES_INST')

# Output directory for the tracking result file (res_track.txt)
# This will create a '01' (or '02' etc.) subdirectory directly under DIC-C2DH-HeLa
TRACKING_OUTPUT_DIR = os.path.join(INSTANCE_MASKS_ROOT, SEQUENCE_NAME)
OUTPUT_TRACK_FILE = os.path.join(TRACKING_OUTPUT_DIR, 'res_track.txt')

# Tracking parameters - you may need to tune these!
IOU_THRESHOLD_TRACK = 0.3  # Minimum IoU to consider a link between objects for tracking
IOU_THRESHOLD_DIVISION = 0.1 # IoU threshold for child candidates in a division scenario.
                             # Can be lower than IOU_THRESHOLD_TRACK as newly divided cells might be smaller/distorted.
MAX_CHILD_CANDIDATES_FOR_DIVISION = 2 # Max number of children one parent can have (e.g., for binary division)

# A class to represent a cell track (lineage)
class CellTrack:
    def __init__(self, label, start_frame, parent_label=-1):
        self.label = label # Unique ID of this track in the lineage tree
        self.start_frame = start_frame
        self.end_frame = start_frame # Initially, ends in the same frame it starts
        self.parent_label = parent_label # ID of parent track, -1 if no parent (root of lineage)
        # self.children = [] # (Optional) Can store child track labels for full tree reconstruction if needed

    def __repr__(self):
        return f"Track(ID={self.label}, Start={self.start_frame}, End={self.end_frame}, Parent={self.parent_label})"


def get_mask_properties(mask):
    """
    Analyzes an instance mask (2D numpy array with unique labels for each object)
    to get properties like bounding box, area, and pixel coordinates for each labeled object.

    Args:
        mask (np.ndarray): A 2D numpy array where each object has a unique positive integer label.
                           Background should be 0.

    Returns:
        dict: A dictionary where keys are object IDs (labels) and values are dictionaries
              containing 'bbox' (min_row, min_col, max_row, max_col), 'area', and 'mask_coords'.
    """
    properties = {}
    labels = np.unique(mask)
    labels = labels[labels != 0] # Exclude background (label 0)

    for label_val in labels:
        coords = np.argwhere(mask == label_val) # Get (row, col) coordinates for all pixels of this object
        if len(coords) == 0:
            continue # Should not happen if label_val came from unique(), but for robustness

        min_row, min_col = np.min(coords, axis=0)
        max_row, max_col = np.max(coords, axis=0)
        area = len(coords) # Number of pixels in the object (its area)

        properties[label_val] = {
            'bbox': (min_row, min_col, max_row, max_col),
            'area': area,
            'mask_coords': coords # Store actual pixel coordinates for precise IoU
        }
    return properties


def calculate_mask_iou(mask1_coords, mask2_coords, mask_shape):
    """
    Calculates the Intersection over Union (IoU) between two sets of pixel coordinates.
    This is more precise than calculating IoU based on bounding boxes.

    Args:
        mask1_coords (np.ndarray): N x 2 array of (row, col) coordinates for object 1.
        mask2_coords (np.ndarray): M x 2 array of (row, col) coordinates for object 2.
        mask_shape (tuple): (height, width) of the original mask to create temporary binary masks.

    Returns:
        float: The IoU score (0.0 to 1.0).
    """
    # Create temporary binary masks from coordinates for intersection/union
    mask1_binary = np.zeros(mask_shape, dtype=bool)
    mask2_binary = np.zeros(mask_shape, dtype=bool)

    if mask1_coords.size > 0:
        mask1_binary[mask1_coords[:, 0], mask1_coords[:, 1]] = True
    if mask2_coords.size > 0:
        mask2_binary[mask2_coords[:, 0], mask2_coords[:, 1]] = True

    intersection = np.sum(np.logical_and(mask1_binary, mask2_binary))
    union = np.sum(np.logical_or(mask1_binary, mask2_binary))

    if union == 0:
        return 0.0 # No overlap and no total area means no objects to compare
    return intersection / union


def track_sequence(instance_masks_dir, output_track_file):
    """
    Performs cell tracking on a sequence of instance masks and generates
    a res_track.txt file in Cell Tracking Challenge format.

    Args:
        instance_masks_dir (str): Directory containing the instance masks (mXXX.tif).
        output_track_file (str): Full path to the output res_track.txt file.
    """
    # Ensure output directory for res_track.txt exists
    os.makedirs(os.path.dirname(output_track_file), exist_ok=True)

    # Get sorted list of instance mask files (e.g., m000.tif, m001.tif, ...)
    mask_files = sorted(glob.glob(os.path.join(instance_masks_dir, 'm*.tif')))
    if not mask_files:
        print(f"Error: No instance masks (mXXX.tif) found in {instance_masks_dir}.")
        print("Please ensure predict.py ran successfully and saved masks to this directory.")
        return

    print(f"Found {len(mask_files)} instance masks for tracking.")

    # Dictionary to store all tracks (CellTrack objects)
    all_tracks = {} # {track_id: CellTrack_object}
    next_track_id = 1 # Global unique ID for new tracks across the entire sequence

    # Store previous frame's object properties for matching
    prev_frame_properties = {}
    # Keep track of which tracks are currently 'active' in the lineage
    active_tracks_by_obj_label = {} # {object_label_in_prev_frame: track_id}

    for frame_idx in range(len(mask_files)):
        current_frame_path = mask_files[frame_idx]
        current_frame_num = int(os.path.basename(current_frame_path)[1:4]) # Extract frame number (e.g., 000, 001)

        print(f"Tracking frame {current_frame_num}...")

        current_mask = np.array(Image.open(current_frame_path))
        current_frame_properties = get_mask_properties(current_mask)
        mask_shape = current_mask.shape # (H, W)

        if frame_idx == 0:
            # For the first frame, all detected objects are new tracks
            for obj_label, props in current_frame_properties.items():
                track = CellTrack(next_track_id, current_frame_num)
                all_tracks[next_track_id] = track
                active_tracks_by_obj_label[obj_label] = next_track_id # Mark as active
                next_track_id += 1
        else:
            # Match objects between previous and current frame
            prev_obj_labels = list(prev_frame_properties.keys())
            curr_obj_labels = list(current_frame_properties.keys())

            num_prev = len(prev_obj_labels)
            num_curr = len(curr_obj_labels)

            matched_prev_indices = set() # Indices in prev_obj_labels that found a match
            matched_curr_indices = set() # Indices in curr_obj_labels that found a match

            if num_prev > 0 and num_curr > 0:
                # Create a cost matrix for bipartite matching (Hungarian algorithm)
                # Cost = 1 - IoU (lower cost for higher IoU)
                cost_matrix = np.ones((num_prev, num_curr)) * 1000 # Initialize with a very high cost (no match)

                # Populate cost matrix with IoU values
                for i, p_label in enumerate(prev_obj_labels):
                    p_coords = prev_frame_properties[p_label]['mask_coords']
                    for j, c_label in enumerate(curr_obj_labels):
                        c_coords = current_frame_properties[c_label]['mask_coords']
                        iou = calculate_mask_iou(p_coords, c_coords, mask_shape)
                        if iou > 0: # Only consider overlaps
                            cost_matrix[i, j] = 1 - iou # Store 1-IoU as cost

                # Use the Hungarian algorithm to find the optimal 1-to-1 assignment
                row_ind, col_ind = linear_sum_assignment(cost_matrix)

                # Process matched pairs
                for i, j in zip(row_ind, col_ind):
                    prev_label = prev_obj_labels[i]
                    curr_label = curr_obj_labels[j]
                    iou = 1 - cost_matrix[i, j] # Convert cost back to IoU

                    if iou >= IOU_THRESHOLD_TRACK:
                        # Check if the previous object label belongs to an active track
                        if prev_label in active_tracks_by_obj_label:
                            track_id = active_tracks_by_obj_label[prev_label]
                            all_tracks[track_id].end_frame = current_frame_num # Extend the track
                            # Update the active object label for this track for the next frame's lookup
                            # Remove old entry and add new entry with current frame's object label
                            del active_tracks_by_obj_label[prev_label]
                            active_tracks_by_obj_label[curr_label] = track_id

                            matched_prev_indices.add(i)
                            matched_curr_indices.add(j)
                        # else: This prev_label was either already ended or part of a division/merge from previous steps (handled later)

            # --- Division Detection (Simplified) ---
            # A division occurs if one object from the previous frame becomes two (or more) objects in the current frame.
            # We look for objects in the previous frame that were *not* matched cleanly (1-to-1)
            # but have high overlap with multiple *unmatched* objects in the current frame.

            # Iterate over prev_obj_labels that were *not* matched 1-to-1
            unmatched_prev_labels = [prev_obj_labels[i] for i in range(num_prev) if i not in matched_prev_indices]

            # Iterate over curr_obj_labels that were *not* matched 1-to-1
            unmatched_curr_labels = [curr_obj_labels[j] for j in range(num_curr) if j not in matched_curr_indices]

            # division_parents_found = set() # Not strictly needed if handling correctly with active_tracks_by_obj_label

            for p_label in unmatched_prev_labels:
                if p_label not in active_tracks_by_obj_label:
                    continue # This parent track already ended or was processed (e.g., merged, or already divided and removed)

                potential_children = []
                p_coords = prev_frame_properties[p_label]['mask_coords']

                for c_label in unmatched_curr_labels:
                    c_coords = current_frame_properties[c_label]['mask_coords']
                    iou = calculate_mask_iou(p_coords, c_coords, mask_shape)
                    if iou >= IOU_THRESHOLD_DIVISION: # A lower threshold for potential children
                        potential_children.append((c_label, iou))

                # If a previous object significantly overlaps with 2 or more unmatched current objects
                # and the number of children is within the allowed limit for a division
                if len(potential_children) >= 2 and len(potential_children) <= MAX_CHILD_CANDIDATES_FOR_DIVISION:
                    # This is a potential division.
                    parent_track_id = active_tracks_by_obj_label[p_label]

                    # Mark the parent track as ending in the previous frame
                    all_tracks[parent_track_id].end_frame = current_frame_num - 1 # Parent track ends before children appear
                    del active_tracks_by_obj_label[p_label] # This track is no longer active by this object label

                    # Create new tracks for the children
                    for child_label, _ in potential_children:
                        new_child_track = CellTrack(next_track_id, current_frame_num, parent_label=parent_track_id)
                        all_tracks[next_track_id] = new_child_track
                        active_tracks_by_obj_label[child_label] = next_track_id # New child track becomes active
                        next_track_id += 1

                        # Mark this child as "matched" so it's not treated as a new object below
                        curr_idx = curr_obj_labels.index(child_label)
                        matched_curr_indices.add(curr_idx)

            # --- Handle truly new objects (appearing without a clear parent or division) ---
            # These are objects in the current frame that were not matched 1-to-1 AND
            # were not identified as children of a division.
            for j, curr_label in enumerate(curr_obj_labels):
                if j not in matched_curr_indices:
                    # Create a new track for this object
                    track = CellTrack(next_track_id, current_frame_num)
                    all_tracks[next_track_id] = track
                    active_tracks_by_obj_label[curr_label] = next_track_id
                    next_track_id += 1

        # Update prev_frame_properties for the next iteration.
        # It's crucial to use current_frame_properties for this.
        prev_frame_properties = current_frame_properties

    # Finalize tracks: Ensure any remaining active track correctly ends at the last frame it appeared.
    # This is handled implicitly by the loop's `end_frame = current_frame_num` for the last frame processed.
    # If a track disappears before the last frame, its `end_frame` will already be correct.

    # Write all historical track data to the output file
    with open(output_track_file, 'w') as f:
        # Sort tracks for consistent output (e.g., by track ID, or start frame then ID)
        sorted_track_ids = sorted(all_tracks.keys(), key=lambda k: (all_tracks[k].start_frame, all_tracks[k].label))
        for track_id in sorted_track_ids:
            track = all_tracks[track_id]
            # Ensure end_frame is never less than start_frame (might happen if object immediately disappears)
            final_end_frame = max(track.start_frame, track.end_frame)
            f.write(f"{track.label} {track.start_frame} {final_end_frame} {track.parent_label}\n")

    print(f"Tracking complete. Results saved to {output_track_file}")
    print(f"Total tracks identified: {len(all_tracks)}")


if __name__ == '__main__':
    # Make sure you have run predict.py first to generate the instance masks!
    # The instance masks should be in the directory specified by INSTANCE_MASKS_DIR.

    print("Starting cell tracking process...")
    track_sequence(INSTANCE_MASKS_DIR, OUTPUT_TRACK_FILE)