import os
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from matplotlib.patches import Polygon
from skimage.measure import regionprops
import glob
from collections import defaultdict

# --- Configuration ---
# Directories for input data
# Original raw images
ORIGINAL_IMAGES_ROOT = 'C:/Users/saura/Downloads/unet-segmentation/data/raw/train/DIC-C2DH-HeLa'
SEQUENCE_NAME = '01'
ORIGINAL_IMAGES_DIR = os.path.join(ORIGINAL_IMAGES_ROOT, SEQUENCE_NAME)

# Instance masks generated by predict.py
INSTANCE_MASKS_ROOT = 'C:/Users/saura/Downloads/unet-segmentation/data/raw/processed/predictions/DIC-C2DH-HeLa'
INSTANCE_MASKS_DIR = os.path.join(INSTANCE_MASKS_ROOT, f'{SEQUENCE_NAME}_RES_INST')

# Tracking results generated by track.py
TRACKING_RESULTS_DIR = os.path.join(INSTANCE_MASKS_ROOT, SEQUENCE_NAME) # Where res_track.txt is saved
TRACK_FILE = os.path.join(TRACKING_RESULTS_DIR, 'res_track.txt')

# Output directory for saving visualizations (optional)
OUTPUT_VIS_DIR = os.path.join(TRACKING_RESULTS_DIR, 'visualizations')
SAVE_PLOTS = True # Set to True to save plots as images, False to display interactively

# --- Utility Functions ---

def load_tracks(track_file_path):
    """
    Loads track information from a res_track.txt file.

    Returns:
        dict: A dictionary where keys are track_ids and values are lists of
              (start_frame, end_frame, parent_id).
              Example: {track_id: {'start': int, 'end': int, 'parent': int}}
    """
    tracks_data = {}
    with open(track_file_path, 'r') as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) == 4:
                track_id = int(parts[0])
                start_frame = int(parts[1])
                end_frame = int(parts[2])
                parent_id = int(parts[3])
                tracks_data[track_id] = {
                    'start': start_frame,
                    'end': end_frame,
                    'parent': parent_id
                }
    print(f"Loaded {len(tracks_data)} tracks.")
    return tracks_data

def get_track_color_map(tracks_data):
    """
    Generates a consistent color map for tracks, potentially coloring parents and children similarly.
    For simplicity, we'll assign unique random colors to each track ID for now.
    A more advanced version would use a lineage-aware coloring.
    """
    # Create a distinct colormap
    # Using 'tab20' or 'hsv' can provide more distinct colors
    cmap = plt.get_cmap('hsv', len(tracks_data) + 1) # +1 for background and new colors
    colors = [cmap(i) for i in range(len(tracks_data) + 1)]
    # Shuffle for better distribution, but make it deterministic for reproducibility
    np.random.seed(42) # For consistent random colors
    np.random.shuffle(colors)

    track_colors = {track_id: colors[i % len(colors)] for i, track_id in enumerate(sorted(tracks_data.keys()))}
    return track_colors


def visualize_frame(frame_num, original_img_path, instance_mask_path, tracks_data, track_colors, output_dir=None):
    """
    Visualizes a single frame with original image, instance mask, and overlaid track IDs.
    """
    try:
        original_img = Image.open(original_img_path).convert("L")
        instance_mask = np.array(Image.open(instance_mask_path))
    except FileNotFoundError as e:
        print(f"Error loading files for frame {frame_num}: {e}. Skipping visualization for this frame.")
        return

    fig, axes = plt.subplots(1, 2, figsize=(16, 8)) # One row, two columns for side-by-side view

    # Plot 1: Original Image
    axes[0].imshow(original_img, cmap='gray')
    axes[0].set_title(f'Frame {frame_num:03d} - Original Image')
    axes[0].axis('off')

    # Plot 2: Instance Mask with Track IDs and Colored Outlines
    axes[1].imshow(original_img, cmap='gray', alpha=0.3) # Original image as background for mask overlay
    axes[1].set_title(f'Frame {frame_num:03d} - Instance Segmentation & Tracks')
    axes[1].axis('off')

    # Create a colormap for the instance mask based on track colors
    # Map instance labels to track IDs first
    label_to_track_id = {}
    for track_id, data in tracks_data.items():
        if data['start'] <= frame_num <= data['end']:
            # This is a bit tricky: the instance_mask uses *its own* arbitrary labels (1, 2, 3...)
            # We need to link these labels back to the track_ids from res_track.txt.
            # This requires storing the original instance label with the track when tracking.
            # Our current track.py only stores a global track_id and parent_id, not the original instance_mask label.
            # For this visualization, we'll make a simplifying assumption:
            # The instance_mask labels are unique for each object in that frame.
            # We'll use these instance_mask labels directly for coloring, but if we want to show TRACK IDs,
            # we need to infer which instance label belongs to which track for *this specific frame*.
            # This is not directly available from res_track.txt alone.

            # HACK: For visualization, let's just color unique instance labels distinctly.
            # To show actual track IDs, we'd need a more complex object -> track mapping from the tracker.
            # For simplicity, let's use a random color for each *instance label* in the current frame,
            # and then overlay the *track ID* at its centroid.
            pass # We'll handle coloring per object_label rather than per track_id for mask overlay

    # Generate a random colormap for individual instances if we don't have track-specific colors for masks
    unique_instance_labels = np.unique(instance_mask[instance_mask > 0])
    # Use a fixed seed for reproducible random colors
    np.random.seed(frame_num) # Different colors for each frame's instances
    # Using 'tab20' or 'viridis' for distinct colors
    instance_cmap = plt.get_cmap('tab20', len(unique_instance_labels) + 1)
    # Define colors for each unique instance label
    instance_label_colors = {
        label: instance_cmap(i % instance_cmap.N) for i, label in enumerate(unique_instance_labels)
    }
    # Create a masked array for plotting with specific colors
    colored_instance_mask = np.zeros(instance_mask.shape + (3,)) # RGB image
    for label, color in instance_label_colors.items():
        colored_instance_mask[instance_mask == label] = color[:3] # Use RGB part of color

    axes[1].imshow(colored_instance_mask, alpha=0.5) # Overlay colored instance mask

    # Get properties for each labeled region (object)
    regions = regionprops(instance_mask)

    # Overlay text (track ID) at the centroid of each cell and draw outlines
    for props in regions:
        if props.label == 0: # Skip background
            continue

        y0, x0 = props.centroid # Centroid (row, col)

        # Get the track ID associated with this instance label in this frame
        # This is the tricky part. We need a way to look up the track ID
        # that was assigned to this specific instance label (props.label)
        # in the track.py script. The current track.py only maintains
        # `active_tracks_by_obj_label = {object_label_in_prev_frame: track_id}`
        # This mapping is transient. To visualize, we need to extend CellTrack
        # to store its instance label for *each frame it exists in*.
        # For a first visualization, let's just display the instance label itself,
        # or we need to modify track.py slightly.

        # *** REVISION FOR DISPLAYING TRACK ID ***
        # To accurately display the track ID, the `track.py` script needs to output
        # a mapping from (frame_num, instance_label) -> track_id.
        # This is not in res_track.txt.
        # For this visualization, we will temporarily just display the *instance label* (props.label)
        # on the image. To display the *track ID*, we would need to store a more detailed
        # object-to-track association from the tracking step or reconstruct it.

        # Let's assume for now that for visualization purposes, the instance label *is* the track ID
        # if the track starts at this frame and its label hasn't changed.
        # A proper way would be to have a dict like `frame_obj_to_track_id[frame_num][obj_label] = track_id`
        # populated during tracking. Since we don't have that easily, we'll stick to instance label.

        # To avoid confusion, let's explicitly state we're showing INSTANCE LABEL
        # If the user asks for true TRACK ID, we'll need to revise the tracking output/storage.
        display_text = str(props.label) # Display the instance label

        axes[1].text(x0, y0, display_text, color='white', ha='center', va='center',
                     fontsize=8, fontweight='bold', bbox=dict(facecolor='black', alpha=0.5, edgecolor='none', pad=1))

        # Draw outline of the cell
        # This can be slow for many cells or large masks.
        # from skimage.segmentation import find_boundaries
        # boundaries = find_boundaries(instance_mask == props.label, mode='inner').astype(np.uint8)
        # axes[1].contour(boundaries, colors='white', linewidths=0.5, alpha=0.7)


    plt.tight_layout()

    if SAVE_PLOTS:
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        save_path = os.path.join(output_dir, f'vis_frame_{frame_num:03d}.png')
        plt.savefig(save_path, dpi=200)
        plt.close(fig) # Close the figure to free memory
        print(f"  Saved visualization for frame {frame_num} to {save_path}")
    else:
        plt.show()


def main():
    # Load track data
    tracks_data = load_tracks(TRACK_FILE)

    # Generate a consistent color map for tracks (optional, as we're just coloring instance labels currently)
    # track_colors = get_track_color_map(tracks_data) # Not used directly for mask colors currently

    # Get list of all original image files and instance mask files
    original_image_files = sorted(glob.glob(os.path.join(ORIGINAL_IMAGES_DIR, 't*.tif')))
    instance_mask_files = sorted(glob.glob(os.path.join(INSTANCE_MASKS_DIR, 'm*.tif')))

    if not original_image_files or not instance_mask_files:
        print("Error: Could not find original images or instance masks. Check paths.")
        return

    # Process each frame
    for i in range(len(original_image_files)):
        frame_num = int(os.path.basename(original_image_files[i])[1:4])
        print(f"Visualizing frame {frame_num}...")
        visualize_frame(frame_num,
                        original_image_files[i],
                        instance_mask_files[i],
                        tracks_data,
                        None, # track_colors (not directly used for mask display for now)
                        OUTPUT_VIS_DIR)

    if SAVE_PLOTS:
        print(f"All visualizations saved to {OUTPUT_VIS_DIR}")
    else:
        print("Finished displaying visualizations.")

if __name__ == '__main__':
    main()